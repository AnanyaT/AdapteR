AS(SELECT 1 AS VECTOR_ID,a.serialval AS VECTOR_INDEX,
CAST(RANDOM(0,100) AS FLOAT)AS VECTOR_VALUE
FROM FL_DEMO.fzzlserial a
WHERE a.serialval < ",ifelse(isRowVec,2,n+1),") WITH DATA ")))
table <- FLTable(connection,
"FL_DEMO",
"test_vectortable_AdapteR",
"VECTOR_INDEX",
whereconditions=paste0("FL_DEMO.test_vectortable_AdapteR.VECTOR_ID = 1")
)
if(isRowVec)
flv <- table[1,base::sample(c("VECTOR_VALUE","VECTOR_INDEX"),n,replace=TRUE)]
else
flv <- table[1:n,"VECTOR_VALUE"]
Rvector <- as.vector(flv)
return(list(FL=flv,R=Rvector))
}
## Increase the value of n to increase the dimensions of FLMatrix returned.
## Returns n*n or n*(n-1) based on isSquare.
initF.FLMatrix <- function(n,isSquare=FALSE)
{
sqlSendUpdate(connection,
c(paste0("DROP TABLE FL_DEMO.test_matrixtable_AdapteR;"),
paste0("CREATE TABLE FL_DEMO.test_matrixtable_AdapteR
AS(SELECT 1 AS MATRIX_ID,a.serialval AS ROW_ID,
b.serialval AS COL_ID,CAST(random(0,100) AS FLOAT)AS CELL_VAL
FROM FL_DEMO.fzzlserial a,FL_DEMO.fzzlserial b
WHERE a.serialval < ",n+1," and b.serialval < ",ifelse(isSquare,n+1,n),") WITH DATA ")))
flm <- FLMatrix(connection,
database          = "FL_DEMO",
matrix_table      = "test_matrixtable_AdapteR",
matrix_id_value   = 1,
matrix_id_colname = "Matrix_ID",
row_id_colname    = "Row_ID",
col_id_colname    = "Col_ID",
cell_val_colname  = "Cell_Val")
Rmatrix <- as.matrix(flm)
return(list(FL=flm,R=Rmatrix))
}
initF.FLTable <- function(rows,cols)
{
WideTable <- FLTable(connection, "FL_DEMO", "fzzlserial","serialval",whereconditions=paste0("FL_DEMO.fzzlserial.serialval<100"))
return(WideTable[1:rows,base::sample(c("randval","serialval"),cols,replace=TRUE)])
}
setMethod("expect_equal",signature("FLMatrix","matrix"),
function(object,expected,...) expect_equal(as.matrix(object),expected,...))
setMethod("expect_equal",signature("FLMatrix","FLMatrix"),
function(object,expected,...) expect_equal(as.matrix(object),as.matrix(expected),...))
setMethod("expect_equal",signature("dgCMatrix","FLMatrix"),
function(object,expected,...) expect_equal(object,as.matrix(expected),...))
setMethod("expect_equal",signature("FLVector","vector"),
function(object,expected,...) expect_equal(as.vector(object),expected,...))
setMethod("expect_equal",signature("FLVector","FLVector"),
function(object,expected,...) expect_equal(as.vector(object),as.vector(expected),...))
setMethod("expect_equal",signature("matrix","matrix"),
function(object,expected,...) testthat::expect_equal(as.vector(object),as.vector(expected),...))
setMethod("expect_equal",signature("list","list"),
function(object,expected,...)
for(i in 1:length(object))
expect_equal(object[[i]],expected[[i]],...))
## Testing FLSolve
test_that("check inverse calculation of matrix", {
expect_eval_equal(initF.FLMatrix,
AdapteR::solve,
base::solve,
n=5,
isSquare=TRUE)
})
# Testing rankMatrix
test_that("check rankMatrix result",{
expect_eval_equal(initF.FLMatrix,
AdapteR::rankMatrix,
Matrix::rankMatrix,
n=5)
})
## Testing FLTranspose
test_that("check transpose",{
expect_eval_equal(initF.FLMatrix,AdapteR::t,base::t,n=5)
})
## Testing FLGinv
test_that("check FLGinv",
{
expect_eval_equal(initF.FLMatrix,AdapteR::ginv,MASS::ginv,n=5)
})
#################################################################
########### no equivqlent R functions to test against ###########
################### but functions work ##########################
## Testing FLHessenDecomp
test_that("check Hessenberg Decomposition",
{
FLHessen(initF.FLMatrix(n=5,isSquare=TRUE)$FL)
})
## Testing FLMatrixRREF
test_that("check FLMatrixRREF working",
{
M <- initF.FLMatrix(n=5,isSquare=TRUE)$FL
expect_equal(
dim(FLMatrixRREF(M)),
dim(M)
)
})
## Testing FLMatrixNorm
test_that("check FLMatrixNorm working",
{
M <- initF.FLMatrix(n=5,isSquare=TRUE)$FL
FLMatrixNorm(M,3)
})
#################################################################################
################### Functions work but output slightly differs ##################
###################### from corresponding R functions ###########################
## Testing FLCholskeyDecomp
### Phani-- needs a hermitian positive definite matrix as input
### Teradata result is transpose of R result.
test_that("check FLCholskeyDecomp",
{
m4 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"MATRIX_ID")
expect_equal(chol(m4), t(Matrix::chol(as.matrix(m4))))
})
devtools::load_all("AdapteR")
## Testing FLTranspose
test_that("check transpose",{
expect_eval_equal(initF.FLMatrix,AdapteR::t,base::t,n=5)
})
devtools::load_all("AdapteR")
devtools::load_all("AdapteR")
WideTable <- FLTable(connection, "FL_TRAIN", "tblVectorWide","vector_key")
colnames(WideTable)
rownames(WideTable)
dim(WideTable)
as.data.frame(WideTable)
v1 <- WideTable[,"vector_value"]
devtools::load_all("AdapteR")
v1 <- WideTable[,"vector_value"]
class(v1)
v2 <- as.data.frame(v1)
devtools::load_all("AdapteR")
v2<-as.vector(v1)
as.data.frame.FLTable(v1)
devtools::load_all("AdapteR")
as.data.frame.FLTable(v1)
v1@isDeep
WideTable <- FLTable(connection, "FL_TRAIN", "tblVectorWide","vector_key")
WideTable@isDeep
v1 <- WideTable[,"vector_value"]
v1@isDeep
t <- new("FLVector",WideTable)
t@isDeep
devtools::load_all("AdapteR")
t <- new("FLVector",WideTable)
t@isDeep
v1@dimnames
v1@variables
WideTable@variables
WideTable@dimnames
devtools::load_all("AdapteR")
v1 <- WideTable[,"vector_value"]
class(v1)
v2 <- as.data.frame.FLTable(v1)
v2
x1 <- WideTable[,c("Vector_key","vector_key")]
class(x1)
x2 <- as.data.frame(x1)
x2
p1 <- WideTable[2,c("Vector_value","vector_key")]
class(p1)
p2 <- as.data.frame.FLTable(p1)
p2
x1 <- WideTable[1:3,c("Vector_value")]
class(x1)
x2 <- as.data.frame(x1)
x1 <- WideTable[1:3,c("Vector_value")]
class(x1)
x2 <- as.data.frame.FLTable(x1)
x2
x1 <- WideTable[3:1,c("Vector_value")]
class(x1)
x2 <- as.data.frame.FLTable(x1)
x2
x1 <- WideTable[1:3,]
class(x1)
x2 <- as.data.frame(x1)
x2
x1 <- WideTable[3:1,]
class(x1)
x2 <- as.data.frame(x1)
x2
m1 <- FLMatrix(connection, "FL_TRAIN", "tblMatrixMulti", 2,
dimnames = list(c("a","b","c"),c("x","y","z")))
m1[]
test_that("check FLEigen",
{
expect_eval_equal(initF.FLMatrix,AdapteR::eigen,base::eigen,n=5,isSquare=TRUE)
})
m5 <- as.FLMatrix(matrix(runif(25,-30,30),5,5),connection) # Random matrix of dimension 5x5
t<-eigen(m5)
t
t<-FLEigenValues(m5)
t
class(t)
as.vector(t)
as.data.frame.FLTable(t)
ncol(t)
devtools::load_all("AdapteR")
as.vector(t)
test_that("check FLEigen",
{
expect_eval_equal(initF.FLMatrix,AdapteR::eigen,base::eigen,n=5,isSquare=TRUE)
})
test_that("check Singular Value Decomposition",
{
expect_eval_equal(initF.FLMatrix,AdapteR::svd,base::svd,n=5)
})
m5 <- as.FLMatrix(matrix(runif(25,-30,30),5,5),connection) # Random matrix of dimension 5x5
t<-svd(m5)
devtools::load_all("AdapteR")
t<-svd(m5)
t
test_that("check Singular Value Decomposition",
{
expect_eval_equal(initF.FLMatrix,AdapteR::svd,base::svd,n=5)
})
test_that("check FLSV working",
{
expect_equal(
length(FLSV(initF.FLMatrix(n=5,isSquare=TRUE)$FL)),
nrow(m5)
)
})
## Testing FLRowMeans
test_that("check rowMeans",
{
expect_eval_equal(initF.FLMatrix,AdapteR::rowMeans,base::rowMeans,n=5)
})
## Testing FLRowSums
test_that("check rowSums",
{
expect_eval_equal(initF.FLMatrix,AdapteR::rowSums,base::rowSums,n=5)
})
test_that("check FLDims",
{
m <- Matrix(c(0,1,0,2),2,sparse=T)
m <- as(m,"dgCMatrix")
M <- as.FLMatrix(m,connection)
T1 <- initF.FLTable(rows=5,cols=5)
T1R <- as.data.frame(T1)
expect_equal(AdapteR::dim.FLMatrix(M),base::dim(m),check.attributes=FALSE)
expect_equal(AdapteR::dim.FLTable(T1),base::dim(T1R),check.attributes=FALSE)
})
devtools::load_all("AdapteR")
M1 <- initF.FLMatrix(n=5,isSquare=TRUE)
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5)
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,10),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,10),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,isRowVec=TRUE)
expect_equal(M1$FL-M2,M1$R-M2R,check.attributes=FALSE)
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"MATRIX_ID")
M2R <- as.matrix(M2)
expect_equal(M1$FL-M2,M1$R-M2R,check.attributes=FALSE)
expect_equal(V1-V2,V1R-V2R,check.attributes=FALSE)
devtools::load_all("AdapteR")
expect_equal(V1-V2,V1R-V2R,check.attributes=FALSE)
V1 <- as.FLVector(sample(1:100,10),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,10),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,isRowVec=TRUE)
expect_equal(V1-V2,V1R-V2R,check.attributes=FALSE)
expect_equal(P1$FL-P1$FL,P1$R-P1$R,check.attributes=FALSE)
expect_equal(V1-P1$FL,V1R-P1$R,check.attributes=FALSE)
expect_equal(P1$FL-V2,P1$R-V2R,check.attributes=FALSE)
expect_equal(M1$FL-V2,M1$R-V2R,check.attributes=FALSE)
expect_equal(M1$FL-P1$FL,M1$R-P1$R,check.attributes=FALSE)
expect_equal(V1-M2,V1R-M2R,check.attributes=FALSE)
expect_equal(P1$FL-M2,P1$R-M2R,check.attributes=FALSE)
devtools::load_all("AdapteR")
expect_equal(P1$FL-V2,P1$R-V2R,check.attributes=FALSE)
expect_equal(M1$FL-V2,M1$R-V2R,check.attributes=FALSE)
expect_equal(M1$FL-P1$FL,M1$R-P1$R,check.attributes=FALSE)
expect_equal(V1-M2,V1R-M2R,check.attributes=FALSE)
expect_equal(P1$FL-M2,P1$R-M2R,check.attributes=FALSE)
## Testing M_Subtraction
test_that("check result for M_Subtraction",
{
M1 <- initF.FLMatrix(n=5,isSquare=TRUE)
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"MATRIX_ID")
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,10),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,10),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,isRowVec=TRUE)
expect_equal(M1$FL-M2,M1$R-M2R,check.attributes=FALSE)
expect_equal(V1-V2,V1R-V2R,check.attributes=FALSE)
expect_equal(P1$FL-P1$FL,P1$R-P1$R,check.attributes=FALSE)
expect_equal(V1-P1$FL,V1R-P1$R,check.attributes=FALSE)
expect_equal(P1$FL-V2,P1$R-V2R,check.attributes=FALSE)
expect_equal(M1$FL-V2,M1$R-V2R,check.attributes=FALSE)
expect_equal(M1$FL-P1$FL,M1$R-P1$R,check.attributes=FALSE)
expect_equal(V1-M2,V1R-M2R,check.attributes=FALSE)
expect_equal(P1$FL-M2,P1$R-M2R,check.attributes=FALSE)
expect_equal(P1$FL-P1$FL-V1-V2-M2-P1$FL-M1$FL-V2,
P1$R-P1$R-V1R-V2R-M2R-P1$R-M1$R-V2R,
check.attributes=FALSE)
})
## Testing M_Subtraction
test_that("check result for M_Subtraction",
{
M1 <- initF.FLMatrix(n=5,isSquare=TRUE)
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"MATRIX_ID")
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,10),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,10),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,isRowVec=TRUE)
expect_equal(M1$FL-M2,M1$R-M2R,check.attributes=FALSE)
expect_equal(V1-V2,V1R-V2R,check.attributes=FALSE)
expect_equal(P1$FL-P1$FL,P1$R-P1$R,check.attributes=FALSE)
expect_equal(V1-P1$FL,V1R-P1$R,check.attributes=FALSE)
expect_equal(P1$FL-V2,P1$R-V2R,check.attributes=FALSE)
expect_equal(M1$FL-V2,M1$R-V2R,check.attributes=FALSE)
expect_equal(M1$FL-P1$FL,M1$R-P1$R,check.attributes=FALSE)
expect_equal(V1-M2,V1R-M2R,check.attributes=FALSE)
expect_equal(P1$FL-M2,P1$R-M2R,check.attributes=FALSE)
expect_equal(P1$FL-P1$FL-V1-V2-M2-P1$FL-M1$FL-V2,
P1$R-P1$R-V1R-V2R-M2R-P1$R-M1$R-V2R,
check.attributes=FALSE)
})
devtools::load_all("AdapteR")
## Testing M_IntegerDivision
test_that("check result for M_IntegerDivision",
{
M1 <- initF.FLMatrix(n=5,isSquare=TRUE)
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"Matrix_id")
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,10),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,10),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,isRowVec=TRUE)
expect_equal(M1$FL%/%M2,M1$R%/%M2R,check.attributes=FALSE)
expect_equal(V1%/%V2,V1R%/%V2R,check.attributes=FALSE)
expect_equal(P1$FL%/%P1$FL,P1$R%/%P1$R,check.attributes=FALSE)
expect_equal(V1%/%P1$FL,V1R%/%P1$R,check.attributes=FALSE)
expect_equal(P1$FL%/%V2,P1$R%/%V2R,check.attributes=FALSE)
expect_equal(M1$FL%/%V2,M1$R%/%V2R,check.attributes=FALSE)
expect_equal(M1$FL%/%P1$FL,M1$R%/%P1$R,check.attributes=FALSE)
expect_equal(V1%/%M2,V1R%/%M2R,check.attributes=FALSE)
expect_equal(P1$FL%/%M2,P1$R%/%M2R,check.attributes=FALSE)
expect_equal(P1$FL%/%P1$FL%/%V1%/%V2%/%M2%/%P1$FL%/%M1$FL%/%V2,
P1$R%/%P1$R%/%V1R%/%V2R%/%M2R%/%P1$R%/%M1$R%/%V2R,
check.attributes=FALSE)
})
expect_equal(M1$FL%/%M2,M1$R%/%M2R,check.attributes=FALSE)
expect_equal(V1%/%V2,V1R%/%V2R,check.attributes=FALSE)
expect_equal(P1$FL%/%P1$FL,P1$R%/%P1$R,check.attributes=FALSE)
expect_equal(V1%/%P1$FL,V1R%/%P1$R,check.attributes=FALSE)
expect_equal(P1$FL%/%V2,P1$R%/%V2R,check.attributes=FALSE)
expect_equal(M1$FL%/%V2,M1$R%/%V2R,check.attributes=FALSE)
expect_equal(M1$FL%/%P1$FL,M1$R%/%P1$R,check.attributes=FALSE)
expect_equal(V1%/%M2,V1R%/%M2R,check.attributes=FALSE)
expect_equal(P1$FL%/%M2,P1$R%/%M2R,check.attributes=FALSE)
expect_equal(P1$FL%/%P1$FL%/%V1%/%V2%/%M2%/%P1$FL%/%M1$FL%/%V2,
P1$R%/%P1$R%/%V1R%/%V2R%/%M2R%/%P1$R%/%M1$R%/%V2R,
check.attributes=FALSE)
P1$R%/%P1$R%/%V1R%/%V2R%/%M2R%/%P1$R%/%M1$R%/%V2R
devtools::load_all("AdapteR")
M1 <- initF.FLMatrix(n=5,isSquare=TRUE)
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"Matrix_id")
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,10),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,10),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,isRowVec=TRUE)
P1$FL%/%P1$FL%/%V1%/%V2%/%M2%/%P1$FL%/%M1$FL%/%V2
devtools::load_all("AdapteR")
P1$FL%/%P1$FL%/%V1%/%V2%/%M2%/%P1$FL%/%M1$FL%/%V2
## Testing M_IntegerDivision
test_that("check result for M_IntegerDivision",
{
M1 <- initF.FLMatrix(n=5,isSquare=TRUE)
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"Matrix_id")
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,10),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,10),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,isRowVec=TRUE)
expect_equal(M1$FL%/%M2,M1$R%/%M2R,check.attributes=FALSE)
expect_equal(V1%/%V2,V1R%/%V2R,check.attributes=FALSE)
expect_equal(P1$FL%/%P1$FL,P1$R%/%P1$R,check.attributes=FALSE)
expect_equal(V1%/%P1$FL,V1R%/%P1$R,check.attributes=FALSE)
expect_equal(P1$FL%/%V2,P1$R%/%V2R,check.attributes=FALSE)
expect_equal(M1$FL%/%V2,M1$R%/%V2R,check.attributes=FALSE)
expect_equal(M1$FL%/%P1$FL,M1$R%/%P1$R,check.attributes=FALSE)
expect_equal(V1%/%M2,V1R%/%M2R,check.attributes=FALSE)
expect_equal(P1$FL%/%M2,P1$R%/%M2R,check.attributes=FALSE)
expect_equal(P1$FL%/%P1$FL%/%V1%/%V2%/%M2%/%P1$FL%/%M1$FL%/%V2,
P1$R%/%P1$R%/%V1R%/%V2R%/%M2R%/%P1$R%/%M1$R%/%V2R,
check.attributes=FALSE)
})
devtools::load_all("AdapteR")
## Testing M_CrossProduct
test_that("check result for M_CrossProduct",
{
M1 <- initF.FLMatrix(n=5) # 5*4 matrix
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",3) # 4*5 matrix
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,5),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,5),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=5,isRowVec=TRUE)
expect_equal(M1$FL%*%M2,M1$R%*%M2R,check.attributes=FALSE)
expect_equal(V1%*%V1,V1R%*%V1R,check.attributes=FALSE)
expect_equal(P1$FL%*%P1$FL,P1$R%*%P1$R,check.attributes=FALSE)
expect_equal(V1%*%P1$FL,V1R%*%P1$R,check.attributes=FALSE)
expect_equal(P1$FL%*%V1,P1$R%*%V1R,check.attributes=FALSE)
expect_equal(M2%*%V2,M2R%*%V2R,check.attributes=FALSE)
expect_equal(M2%*%P1$FL,M2R%*%P1$R,check.attributes=FALSE)
expect_equal(V1%*%M1$FL,V1R%*%M1$R,check.attributes=FALSE)
expect_equal(P1$FL%*%M1$FL,P1$R%*%M1$R,check.attributes=FALSE)
})
test_that("check result for M_CrossProduct",
{
M1 <- initF.FLMatrix(n=5) # 5*4 matrix
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",3,"MATRIX_ID") # 4*5 matrix
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,5),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,5),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=5,isRowVec=TRUE)
expect_equal(M1$FL%*%M2,M1$R%*%M2R,check.attributes=FALSE)
expect_equal(V1%*%V1,V1R%*%V1R,check.attributes=FALSE)
expect_equal(P1$FL%*%P1$FL,P1$R%*%P1$R,check.attributes=FALSE)
expect_equal(V1%*%P1$FL,V1R%*%P1$R,check.attributes=FALSE)
expect_equal(P1$FL%*%V1,P1$R%*%V1R,check.attributes=FALSE)
expect_equal(M2%*%V2,M2R%*%V2R,check.attributes=FALSE)
expect_equal(M2%*%P1$FL,M2R%*%P1$R,check.attributes=FALSE)
expect_equal(V1%*%M1$FL,V1R%*%M1$R,check.attributes=FALSE)
expect_equal(P1$FL%*%M1$FL,P1$R%*%M1$R,check.attributes=FALSE)
})
## Testing FLIs
test_that("check FLIs",
{
expect_eval_equal(initF.FLMatrix,AdapteR::is.FLMatrix,base::is.matrix,n=5)
expect_eval_equal(initF.FLVector,AdapteR::is.FLVector,base::is.vector,n=5)
expect_eval_equal(initF.FLVector,AdapteR::is.FLVector,base::is.vector,n=5,isRowVec=TRUE)
expect_is(initF.FLTable(rows=5,cols=4),"FLTable")
})
## Testing FLCastFunctions
test_that("check FLCastFunctions",
{
M1 <- initF.FLMatrix(n=5)
V1 <- as.FLVector(sample(1:100,5),connection)
V1R <- as.vector(V1)
P1 <- initF.FLVector(n=5,isRowVec=TRUE)
T1 <- initF.FLTable(rows=5,cols=5)
expect_equal(as.vector(M1$FL),as.vector(M1$R),check.attributes=FALSE)
expect_equal(as.vector(P1$FL),as.vector(P1$R),check.attributes=FALSE)
expect_equal(as.data.frame(M1$FL),as.data.frame(M1$R),check.attributes=FALSE)
testthat::expect_equal(as.matrix(P1$FL),as.matrix(P1$R),check.attributes=FALSE)
testthat::expect_equal(as.matrix(V1),as.matrix(V1R),check.attributes=FALSE)
expect_equal(as.FLMatrix(M1$R,connection),as.matrix(M1$FL),check.attributes=FALSE)
expect_equal(as.FLMatrix(P1$FL),as.matrix(P1$R),check.attributes=FALSE)
expect_equal(as.FLMatrix(V1),as.matrix(V1R),check.attributes=FALSE)
expect_equal(as.FLMatrix(P1$R,connection),as.matrix(P1$R),check.attributes=FALSE)
expect_equal(as.FLVector(M1$R,connection),as.vector(M1$R),check.attributes=FALSE)
expect_equal(as.FLVector(M1$FL),as.matrix(M1$R),check.attributes=FALSE)
})
eqnRtn <- FLMatrix(
connection,
database          = "FL_DEMO",
matrix_table      = "finEquityReturns",
matrix_id_value   = "",
matrix_id_colname = "",
row_id_colname    = "TxnDate",
col_id_colname    = "TickerSymbol",
cell_val_colname  = "EquityReturn")
m <- eqnRtn[1:10,"MSFT"]
m
rMatrix <- matrix(1:25,5)
m <- as.FLMatrix(rMatrix,connection)
expect_equal(as.matrix(m),rMatrix)
expect_equal(as.matrix(m[1,]),rMatrix[1,])
t<-m[1,]
t
expect_equal(m[1,],rMatrix[1,])
class(t)
expect_equal(as.matrix(m[1,]),rMatrix[1,],check.attributes=FALSE)
class(as.matrix(t))
expect_equal(as.matrix(m[1,]),as.matrix(rMatrix[1,]),check.attributes=FALSE)
class(rMatrix[1,])
rMatrix[1,]
rMatrix
m<-matrix(1:4,2)
class(m[1,])
class(m[1:2,])
class(m[1,2])
expect_equal(as.matrix(m[1,]),as.matrix(rMatrix[1,]))
expect_equal(as.matrix(m[2:3,4:5]),rMatrix[2:3,4:5])
m<-as.FLMatrix(rMatrix,connection)
expect_equal(as.matrix(m[1,]),as.matrix(rMatrix[1,]),check.attributes=FALSE)
expect_equal(as.matrix(m[2:3,4:5]),rMatrix[2:3,4:5],check.attributes=FALSE)
m[2:3,4;5]
m[2:3,4:5]
t<-eqnRtn-eqnRtn
