expect_equal(chol(m4),
Matrix::chol(as.matrix(m4)))
})
# Testing FLLUDecomp
test_that("check LU Decomposition",
{
m <- initF.FLMatrix(n=5)
expect_equal(AdapteR::expand(AdapteR::lu(m$FL)),
Matrix::expand(Matrix::lu(m$R)),check.attributes=FALSE)
})
## Testing FLLength
test_that("check length",
{
T1 <- initF.FLTable(rows=5,cols=5)
T1R <- as.data.frame(T1)
expect_eval_equal(initF.FLMatrix,AdapteR::length,base::length,n=5)
expect_eval_equal(initF.FLVector,AdapteR::length,base::length,n=5)
expect_eval_equal(initF.FLVector,AdapteR::length,base::length,n=5,isRowVec=TRUE)
expect_equal(AdapteR::length(T1),base::length(T1R),check.attributes=FALSE)
})
## Testing FLTrace
test_that("check FLTrace",
{
expect_eval_equal(initF.FLMatrix,
AdapteR::tr,
psych::tr,
n=5,
isSquare=TRUE)
})
##Testing FLDiag
test_that("check the result of the diag of matrix",
{
expect_eval_equal(initF.FLMatrix,
AdapteR::diag,
base::diag,
n=5)
expect_eval_equal(initF.FLVector,
AdapteR::diag,
base::diag,
n=5)
expect_eval_equal(initF.FLVector,
AdapteR::diag,
base::diag,
n=5,isRowVec=TRUE)
expect_eval_equal(initF.FLVector,
AdapteR::diag,
base::diag,
n=1)
expect_eval_equal(initF.FLVector,
AdapteR::diag,
base::diag,
n=1,isRowVec=TRUE)
})
## Testing M_Subtraction
## gk: todo: refactor SQL statements for performance.  This is bad performance.
test_that("check result for Matrix M_Subtraction",
{
expect_eval_equal(initF=function(n,isSquare=FALSE) {
a <- initF.FLMatrix(n,isSquare)
b <- FLMatrix(connection,
"FL_DEMO", "tblmatrixMulti",
5, "MATRIX_ID",
"ROW_ID","COL_ID","CELL_VAL")
list(R=list(a$R,
as.matrix(b)),
FL=list(a$FL,
b))
},function(x) (do.call("-",x)),
function(x) do.call("-",x),n=5,isSquare=TRUE
)
})
## Testing M_Subtraction
## gk: todo: refactor SQL statements for performance.  This is bad performance.
test_that("check result for M_Subtraction",
{
M1 <- initF.FLMatrix(n=5,isSquare=TRUE)
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"MATRIX_ID","ROW_ID","COL_ID","CELL_VAL")
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,10),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,10),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,isRowVec=TRUE)
expect_equal(M1$FL-M2,M1$R-M2R,check.attributes=FALSE)
expect_equal(V1-V2,V1R-V2R,check.attributes=FALSE)
expect_equal(P1$FL-P1$FL,P1$R-P1$R,check.attributes=FALSE)
expect_equal(V1-P1$FL,V1R-P1$R,check.attributes=FALSE)
expect_equal(P1$FL-V2,P1$R-V2R,check.attributes=FALSE)
expect_equal((M1$FL-V2),M1$R-V2R,check.attributes=FALSE)
expect_equal((M1$FL-P1$FL),M1$R-P1$R,check.attributes=FALSE)
expect_equal((V1-M2),V1R-M2R,check.attributes=FALSE)
expect_equal((P1$FL-M2),P1$R-M2R,check.attributes=FALSE)
expect_equal((P1$FL-P1$FL-V1-V2-M2-P1$FL-M1$FL-V2),
P1$R-P1$R-V1R-V2R-M2R-P1$R-M1$R-V2R,
check.attributes=FALSE)
})
## Testing M_IntegerDivision. Only 2 FLMatrices
test_that("check result for M_IntegerDivision",
{
expect_eval_equal(initF=function(n) {
a <- initF.FLMatrix(n=5,isSquare=TRUE)
b <- FLMatrix(connection,
"FL_DEMO", "tblmatrixMulti",
5, "MATRIX_ID",
"ROW_ID","COL_ID","CELL_VAL")
list(R=list(a$R,
as.matrix(b)),
FL=list(a$FL,
b))
},function(x) (do.call("%/%",x)),
function(x) do.call("%/%",x)
)
})
## Testing M_IntegerDivision
## Bad performance
test_that("check result for M_IntegerDivision",
{
M1 <- initF.FLMatrix(n=5,isSquare=TRUE)
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"Matrix_id","ROW_ID","COL_ID","CELL_VAL")
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,10),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,10),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,isRowVec=TRUE)
expect_equal((M1$FL%/%M2),M1$R%/%M2R,check.attributes=FALSE)
expect_equal((V1%/%V2),V1R%/%V2R,check.attributes=FALSE)
expect_equal((P1$FL%/%P1$FL),P1$R%/%P1$R,check.attributes=FALSE)
expect_equal((V1%/%P1$FL),V1R%/%P1$R,check.attributes=FALSE)
expect_equal((P1$FL%/%V2),P1$R%/%V2R,check.attributes=FALSE)
expect_equal((M1$FL%/%V2),M1$R%/%V2R,check.attributes=FALSE)
expect_equal((M1$FL%/%P1$FL),M1$R%/%P1$R,check.attributes=FALSE)
expect_equal((V1%/%M2),V1R%/%M2R,check.attributes=FALSE)
expect_equal((P1$FL%/%M2),P1$R%/%M2R,check.attributes=FALSE)
})
## Testing M_CrossProduct only two FLMatrices
test_that("check result for M_CrossProduct",
{
expect_eval_equal(initF=function(n) {
a <- initF.FLMatrix(n=5)
b <- FLMatrix(connection,
"FL_DEMO", "tblmatrixMulti",
3, "MATRIX_ID",
"ROW_ID","COL_ID","CELL_VAL")
list(R=list(a$R,
as.matrix(b)),
FL=list(a$FL,
b))
},function(x) (do.call("%*%",x)),
function(x) do.call("%*%",x)
)
})
## Testing M_CrossProduct
## Bad performance
test_that("check result for M_CrossProduct",
{
M1 <- initF.FLMatrix(n=5) # 5*4 matrix
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",3,"MATRIX_ID","ROW_ID","COL_ID","CELL_VAL") # 4*5 matrix
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,5),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,5),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=5,isRowVec=TRUE)
expect_equal((M1$FL %*% M2),M1$R%*%M2R,check.attributes=FALSE)
expect_equal((V1%*%V1),V1R%*%V1R,check.attributes=FALSE)
expect_equal((P1$FL%*%P1$FL),P1$R%*%P1$R,check.attributes=FALSE)
expect_equal((V1%*%P1$FL),V1R%*%P1$R,check.attributes=FALSE)
expect_equal((P1$FL%*%V1),P1$R%*%V1R,check.attributes=FALSE)
expect_equal((M2%*%V2),M2R%*%V2R,check.attributes=FALSE)
expect_equal((M2%*%P1$FL),M2R%*%P1$R,check.attributes=FALSE)
expect_equal((V1%*%M1$FL),V1R%*%M1$R,check.attributes=FALSE)
expect_equal((P1$FL%*%M1$FL),P1$R%*%M1$R,check.attributes=FALSE)
})
## Testing M_Addition
## gk: todo: refactor SQL statements for performance.  This is bad performance.
test_that("check result for Matrix M_Addition",
{
expect_eval_equal(initF=function(n,isSquare=FALSE) {
a <- initF.FLMatrix(n,isSquare)
b <- FLMatrix(connection,
"FL_DEMO", "tblmatrixMulti",
5, "MATRIX_ID",
"ROW_ID","COL_ID","CELL_VAL")
list(R=list(a$R,
as.matrix(b)),
FL=list(a$FL,
b))
},function(x) (do.call("+",x)),
function(x) do.call("+",x),n=5,isSquare=TRUE
)
})
## Testing M_Addition
test_that("check result for M_Addition",
{
M1 <- initF.FLMatrix(n=5,isSquare=TRUE)
M2 <- FLMatrix(connection,
"FL_DEMO", "tblmatrixMulti",
5, "MATRIX_ID",
"ROW_ID","COL_ID","CELL_VAL")
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,10),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,10),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,isRowVec=TRUE)
expect_equal(M1$FL+M2,
M1$R+M2R,
check.attributes=FALSE)
expect_equal(V1+V2,
V1R+V2R,
check.attributes=FALSE)
expect_equal(P1$FL+P1$FL,
P1$R+P1$R,
check.attributes=FALSE)
expect_equal(V1+P1$FL,
V1R+P1$R,
check.attributes=FALSE)
expect_equal(P1$FL+V2,
P1$R+V2R,
check.attributes=FALSE)
expect_equal(M1$FL+V2,
M1$R+V2R,
check.attributes=FALSE)
expect_equal(M1$FL+P1$FL,
M1$R+P1$R,
check.attributes=FALSE)
expect_equal(V1+M2,
V1R+M2R,
check.attributes=FALSE)
expect_equal(P1$FL+M2,
P1$R+M2R,
check.attributes=FALSE)
expect_equal(P1$FL+P1$FL+V1+V2+M2+P1$FL+M1$FL+V2,
P1$R+P1$R+V1R+V2R+M2R+P1$R+M1$R+V2R,
check.attributes=FALSE)
})
## Testing M_Division
test_that("check result for M_Division",
{
M1 <- initF.FLMatrix(n=5,
isSquare=TRUE)
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",
5,"Matrix_id","ROW_ID","COL_ID","CELL_VAL")
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,
10),
connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,
10),
connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,
isRowVec=TRUE)
expect_equal((M1$FL/M2),
M1$R/M2R,
check.attributes=FALSE)
expect_equal((V1/V2),
V1R/V2R,
check.attributes=FALSE)
expect_equal((P1$FL/P1$FL),
P1$R/P1$R,
check.attributes=FALSE)
expect_equal((V1/P1$FL),
V1R/P1$R,
check.attributes=FALSE)
expect_equal((P1$FL/V2),
P1$R/V2R,
check.attributes=FALSE)
expect_equal((M1$FL/V2),
M1$R/V2R,
check.attributes=FALSE)
expect_equal((M1$FL/P1$FL),
M1$R/P1$R,
check.attributes=FALSE)
expect_equal((V1/M2),
V1R/M2R,
check.attributes=FALSE)
expect_equal((P1$FL/M2),
P1$R/M2R,
check.attributes=FALSE)
})
## Testing M_Multiplication
test_that("check result for M_Multiplication",
{
M1 <- initF.FLMatrix(n=5,isSquare=TRUE)
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"Matrix_id","ROW_ID","COL_ID","CELL_VAL")
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,10),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,10),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,isRowVec=TRUE)
expect_equal(M1$FL*M2,M1$R*M2R,check.attributes=FALSE)
expect_equal(V1*V2,V1R*V2R,check.attributes=FALSE)
expect_equal(P1$FL*P1$FL,P1$R*P1$R,check.attributes=FALSE)
expect_equal(V1*P1$FL,V1R*P1$R,check.attributes=FALSE)
expect_equal(P1$FL*V2,P1$R*V2R,check.attributes=FALSE)
expect_equal(M1$FL*V2,M1$R*V2R,check.attributes=FALSE)
expect_equal(M1$FL*P1$FL,M1$R*P1$R,check.attributes=FALSE)
expect_equal(V1*M2,V1R*M2R,check.attributes=FALSE)
expect_equal(P1$FL*M2,P1$R*M2R,check.attributes=FALSE)
expect_equal(P1$FL*P1$FL*V1*V2*M2*P1$FL*M1$FL*V2,
P1$R*P1$R*V1R*V2R*M2R*P1$R*M1$R*V2R,
check.attributes=FALSE)
})
## Testing M_Remainder
test_that("check result for M_Remainder",
{
M1 <- initF.FLMatrix(n=5,isSquare=TRUE)
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"Matrix_id","ROW_ID","COL_ID","CELL_VAL")
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,10),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,10),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,isRowVec=TRUE)
expect_equal((M1$FL%%M2),M1$R%%M2R,check.attributes=FALSE)
expect_equal((V1%%V2),V1R%%V2R,check.attributes=FALSE)
expect_equal((P1$FL%%P1$FL),P1$R%%P1$R,check.attributes=FALSE)
expect_equal((V1%%P1$FL),V1R%%P1$R,check.attributes=FALSE)
expect_equal((P1$FL%%V2),P1$R%%V2R,check.attributes=FALSE)
expect_equal((M1$FL%%V2),M1$R%%V2R,check.attributes=FALSE)
expect_equal((M1$FL%%P1$FL),M1$R%%P1$R,check.attributes=FALSE)
expect_equal((V1%%M2),V1R%%M2R,check.attributes=FALSE)
expect_equal((P1$FL%%M2),P1$R%%M2R,check.attributes=FALSE)
})
## Testing Equality
test_that("check result for M_Equality",
{
M1 <- initF.FLMatrix(n=5,isSquare=TRUE)
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"Matrix_id","ROW_ID","COL_ID","CELL_VAL")
M3 <- as.FLMatrix(as.matrix(M2),connection)
M3R <- as.matrix(M2)
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,10),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,10),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,isRowVec=TRUE)
expect_equal(M1$FL==M2,(M1$R==M2R),check.attributes=FALSE)
expect_equal(M1$FL==M1$FL,M1$R==M1$R,check.attributes=FALSE)
expect_equal(M2==M3,M2R==M3R,check.attributes=FALSE)
expect_equal(V1==V1R,V1R==V1R,check.attributes=FALSE)
expect_equal(P1$FL==P1$FL,P1$R==P1$R,check.attributes=FALSE)
expect_equal(V1==P1$FL,V1R==P1$R,check.attributes=FALSE)
expect_equal(P1$FL==P1$R,P1$R==P1$R,check.attributes=FALSE)
#expect_equal(M1$FL==V2,M1$R==V2R,check.attributes=FALSE)
#expect_equal(M1$FL==P1$FL,M1$R==P1$R,check.attributes=FALSE)
expect_equal(V1==V1,V1R==V1R,check.attributes=FALSE)
#expect_equal(P1$FL==M2,P1$R==M2R,check.attributes=FALSE)
})
## Testing FLIdentical
test_that("check result for identical",
{
M1 <- initF.FLMatrix(n=5,isSquare=TRUE)
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"Matrix_id","ROW_ID","COL_ID","CELL_VAL")
M3 <- as.FLMatrix(as.matrix(M2),connection)
M3R <- as.matrix(M2)
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,10),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,10),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,isRowVec=TRUE)
expect_equal(identical(M1$FL,M2),identical(M1$R,M2R),check.attributes=FALSE)
expect_equal(identical(M1$FL,M1$FL),identical(M1$R,M1$R),check.attributes=FALSE)
expect_equal(identical(M2,M3),identical(M2R,M3R),check.attributes=FALSE)
expect_equal(identical(V1,V1R),identical(V1R,V1R),check.attributes=FALSE)
expect_equal(identical(P1$FL,P1$FL),identical(P1$R,P1$R),check.attributes=FALSE)
expect_equal(identical(V1,P1$FL),identical(V1R,P1$R),check.attributes=FALSE)
expect_equal(identical(P1$FL,P1$R),identical(P1$R,P1$R),check.attributes=FALSE)
expect_equal(identical(M1$FL,V2),identical(M1$R,V2R),check.attributes=FALSE)
expect_equal(identical(M1$FL,P1$FL),identical(M1$R,P1$R),check.attributes=FALSE)
expect_equal(identical(V1,V1),identical(V1R,V1R),check.attributes=FALSE)
expect_equal(identical(P1$FL,M2),identical(P1$R,M2R),check.attributes=FALSE)
})
#################################################################
########### no equivqlent R functions to test against ###########
################### but functions work ##########################
## Testing FLSV
test_that("check FLSV working",
{
M <- initF.FLMatrix(n=5,isSquare=TRUE)$FL
expect_equal(
length(FLSV(M)),
nrow(M)
)
})
## Testing FLHessenDecomp
test_that("check Hessenberg Decomposition",
{
FLHessen(initF.FLMatrix(n=5,isSquare=TRUE)$FL)
})
## Testing FLMatrixRREF
test_that("check FLMatrixRREF working",
{
M <- initF.FLMatrix(n=5,isSquare=TRUE)$FL
expect_equal(
dim(FLMatrixRREF(M)),
dim(M)
)
expect_equal(
dimnames(FLMatrixRREF(M)),
dimnames(M)
)
})
## Testing FLMatrixREF
test_that("check FLMatrixREF",
{
FLMatrixREF(initF.FLMatrix(n=5,isSquare=TRUE)$FL)
})
## Testing FLMatrixNorm
test_that("check FLMatrixNorm working",
{
M <- initF.FLMatrix(n=5,isSquare=TRUE)$FL
FLMatrixNorm(M,3)
})
##Testing FLJordon
### Phani-- works only with matrices with non-complex
### eigen values. So input taken from DbLytix manual.
test_that("check Jordan Decomposition",
{
M <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"Matrix_id","ROW_ID","COL_ID","CELL_VAL")
FLJordan(M)
})
## Testing FLSolveExcl
test_that("check FLSolveExcl",
{
M <- initF.FLMatrix(n=5,isSquare=TRUE)$FL
expect_equal(dim(FLSolveExcl(M,3)),dim(M)-1)
expect_equal(dim(FLSolveExcl(M,6)),dim(M))
})
## Testing FLTriDiag
test_that("check FLTriDiag",
{
FLTriDiag(initF.FLMatrix(n=5,isSquare=TRUE)$FL)
})
#################################################################################
################### Functions work but output slightly differs ##################
###################### from corresponding R functions ###########################
## gk: discuss with Raman for JIRA DBlytix
## Testing FLEigen
## Phani -- results differ in Teradata and R
test_that("check FLEigen",
{
expect_eval_equal(initF.FLMatrix,
AdapteR::eigen,
function(m)
llply(base::eigen(m),
as.numeric),
n=5,
isSquare=TRUE)
})
## Testing FLSVDecomp
## Phani -- results differ in Teradata and R
test_that("check Singular Value Decomposition",
{
expect_eval_equal(initF.FLMatrix,AdapteR::svd,base::svd,n=5)
})
## Testing FLDet
### Phani-- for some matrices R output = -(DBLytix output)
test_that("check determinant result",{
expect_eval_equal(initF.FLMatrix,AdapteR::det,base::det,n=5,isSquare=TRUE)
})
## Testing FLQRDecomposition
### Phani-- could not calculate pivot properly,
### also, output qr matrix differs from R
test_that("check FLQRDecomposition",
{
M <- initF.FLMatrix(n=5)
expect_eval_equal(initF.FLMatrix,AdapteR::qr,base::qr,n=5)
})
####################################################################################################
####################################################################################################
#***************************************************************************************************
#***************************************************************************************************
#################################################################################
############################# Non Working Tests #################################
#################################################################################
## Testing FLTranspose
## gk:  that is broken since rbind
test_that("check transpose",{
expect_eval_equal(initF.FLMatrix,AdapteR::t,base::t,n=5)
})
## Testing FLRowMeans
test_that("check rowMeans",
{
expect_eval_equal(initF.FLMatrix,
AdapteR::rowMeans,
base::rowMeans,
n=5)
})
## Testing FLRowSums
test_that("check rowSums",
{
expect_eval_equal(initF.FLMatrix,
AdapteR::rowSums,
base::rowSums,
n=5)
})
## Testing FLColMeans
test_that("check colMeans",
{
expect_eval_equal(initF.FLMatrix,AdapteR::colMeans,base::colMeans,n=5)
})
## Testing FLColSums
test_that("check colSums",
{
expect_eval_equal(initF.FLMatrix,AdapteR::colSums,base::colSums,n=5)
})
