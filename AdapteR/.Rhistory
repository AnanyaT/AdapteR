V1 <- as.FLVector(sample(1:100,10),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,10),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,isRowVec=TRUE)
expect_equal(M1$FL-M2,M1$R-M2R,check.attributes=FALSE)
expect_equal(V1-V2,V1R-V2R,check.attributes=FALSE)
expect_equal(P1$FL-P1$FL,P1$R-P1$R,check.attributes=FALSE)
expect_equal(V1-P1$FL,V1R-P1$R,check.attributes=FALSE)
expect_equal(P1$FL-V2,P1$R-V2R,check.attributes=FALSE)
expect_equal(M1$FL-V2,M1$R-V2R,check.attributes=FALSE)
expect_equal(M1$FL-P1$FL,M1$R-P1$R,check.attributes=FALSE)
expect_equal(V1-M2,V1R-M2R,check.attributes=FALSE)
expect_equal(P1$FL-M2,P1$R-M2R,check.attributes=FALSE)
expect_equal(P1$FL-P1$FL-V1-V2-M2-P1$FL-M1$FL-V2,
P1$R-P1$R-V1R-V2R-M2R-P1$R-M1$R-V2R,
check.attributes=FALSE)
})
V1-P1$FL
devtools::load_all("AdapteR")
test_that("check result for M_Subtraction",
{
M1 <- initF.FLMatrix(n=5,isSquare=TRUE)
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"MATRIX_ID","ROW_ID","COL_ID","CELL_VAL")
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,10),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,10),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,isRowVec=TRUE)
expect_equal(M1$FL-M2,M1$R-M2R,check.attributes=FALSE)
expect_equal(V1-V2,V1R-V2R,check.attributes=FALSE)
expect_equal(P1$FL-P1$FL,P1$R-P1$R,check.attributes=FALSE)
expect_equal(V1-P1$FL,V1R-P1$R,check.attributes=FALSE)
expect_equal(P1$FL-V2,P1$R-V2R,check.attributes=FALSE)
expect_equal(M1$FL-V2,M1$R-V2R,check.attributes=FALSE)
expect_equal(M1$FL-P1$FL,M1$R-P1$R,check.attributes=FALSE)
expect_equal(V1-M2,V1R-M2R,check.attributes=FALSE)
expect_equal(P1$FL-M2,P1$R-M2R,check.attributes=FALSE)
expect_equal(P1$FL-P1$FL-V1-V2-M2-P1$FL-M1$FL-V2,
P1$R-P1$R-V1R-V2R-M2R-P1$R-M1$R-V2R,
check.attributes=FALSE)
})
devtools::load_all("AdapteR")
test_that("check result for M_IntegerDivision",
{
expect_eval_equal(initF=function(n) {
a <- initF.FLMatrix(n=5,isSquare=TRUE)
b <- FLMatrix(connection,
"FL_DEMO", "tblmatrixMulti",
5, "MATRIX_ID",
"ROW_ID","COL_ID","CELL_VAL")
list(R=list(a$R,
as.matrix(b)),
FL=list(a$FL,
b))
},function(x) do.call("%/%",x),
function(x) do.call("%/%",x)
)
})
test_that("check result for M_IntegerDivision",
{
M1 <- initF.FLMatrix(n=5,isSquare=TRUE)
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"Matrix_id","ROW_ID","COL_ID","CELL_VAL")
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,10),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,10),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,isRowVec=TRUE)
expect_equal(M1$FL%/%M2,M1$R%/%M2R,check.attributes=FALSE)
expect_equal(V1%/%V2,V1R%/%V2R,check.attributes=FALSE)
expect_equal(P1$FL%/%P1$FL,P1$R%/%P1$R,check.attributes=FALSE)
expect_equal(V1%/%P1$FL,V1R%/%P1$R,check.attributes=FALSE)
expect_equal(P1$FL%/%V2,P1$R%/%V2R,check.attributes=FALSE)
expect_equal(M1$FL%/%V2,M1$R%/%V2R,check.attributes=FALSE)
expect_equal(M1$FL%/%P1$FL,M1$R%/%P1$R,check.attributes=FALSE)
expect_equal(V1%/%M2,V1R%/%M2R,check.attributes=FALSE)
expect_equal(P1$FL%/%M2,P1$R%/%M2R,check.attributes=FALSE)
})
M1 <- initF.FLMatrix(n=5,isSquare=TRUE)
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"Matrix_id","ROW_ID","COL_ID","CELL_VAL")
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,10),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,10),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,isRowVec=TRUE)
devtools::load_all("AdapteR")
expect_equal(V1%/%V2,V1R%/%V2R,check.attributes=FALSE)
devtools::load_all("AdapteR")
test_that("check result for M_IntegerDivision",
{
M1 <- initF.FLMatrix(n=5,isSquare=TRUE)
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"Matrix_id","ROW_ID","COL_ID","CELL_VAL")
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,10),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,10),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=10,isRowVec=TRUE)
expect_equal(M1$FL%/%M2,M1$R%/%M2R,check.attributes=FALSE)
expect_equal(V1%/%V2,V1R%/%V2R,check.attributes=FALSE)
expect_equal(P1$FL%/%P1$FL,P1$R%/%P1$R,check.attributes=FALSE)
expect_equal(V1%/%P1$FL,V1R%/%P1$R,check.attributes=FALSE)
expect_equal(P1$FL%/%V2,P1$R%/%V2R,check.attributes=FALSE)
expect_equal(M1$FL%/%V2,M1$R%/%V2R,check.attributes=FALSE)
expect_equal(M1$FL%/%P1$FL,M1$R%/%P1$R,check.attributes=FALSE)
expect_equal(V1%/%M2,V1R%/%M2R,check.attributes=FALSE)
expect_equal(P1$FL%/%M2,P1$R%/%M2R,check.attributes=FALSE)
})
l<-list(c(1:2),3:4)
l[[1]]
devtools::load_all("AdapteR")
test_that("check result for M_CrossProduct",
{
expect_eval_equal(initF=function(n) {
a <- initF.FLMatrix(n=5)
b <- FLMatrix(connection,
"FL_DEMO", "tblmatrixMulti",
3, "MATRIX_ID",
"ROW_ID","COL_ID","CELL_VAL")
list(R=list(a$R,
as.matrix(b)),
FL=list(a$FL,
b))
},function(x) do.call("%*%",x),
function(x) do.call("%*%",x)
)
})
test_that("check result for M_CrossProduct",
{
M1 <- initF.FLMatrix(n=5) # 5*4 matrix
M2 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",3,"MATRIX_ID","ROW_ID","COL_ID","CELL_VAL") # 4*5 matrix
M2R <- as.matrix(M2)
V1 <- as.FLVector(sample(1:100,5),connection)
V1R <- as.vector(V1)
V2 <- as.FLVector(sample(1:100,5),connection)
V2R <- as.vector(V2)
P1 <- initF.FLVector(n=5,isRowVec=TRUE)
expect_equal(M1$FL %*% M2,M1$R%*%M2R,check.attributes=FALSE)
expect_equal(V1%*%V1,V1R%*%V1R,check.attributes=FALSE)
expect_equal(P1$FL%*%P1$FL,P1$R%*%P1$R,check.attributes=FALSE)
expect_equal(V1%*%P1$FL,V1R%*%P1$R,check.attributes=FALSE)
expect_equal(P1$FL%*%V1,P1$R%*%V1R,check.attributes=FALSE)
expect_equal(M2%*%V2,M2R%*%V2R,check.attributes=FALSE)
expect_equal(M2%*%P1$FL,M2R%*%P1$R,check.attributes=FALSE)
expect_equal(V1%*%M1$FL,V1R%*%M1$R,check.attributes=FALSE)
expect_equal(P1$FL%*%M1$FL,P1$R%*%M1$R,check.attributes=FALSE)
})
test_that("check FLIs",
{
expect_eval_equal(initF.FLMatrix,AdapteR::is.FLMatrix,base::is.matrix,n=5)
expect_eval_equal(initF.FLVector,AdapteR::is.FLVector,base::is.vector,n=5)
expect_eval_equal(initF.FLVector,AdapteR::is.FLVector,base::is.vector,n=5,isRowVec=TRUE)
expect_is(initF.FLTable(rows=5,cols=4),"FLTable")
})
## Testing FLCastFunctions
test_that("check FLCastFunctions",
{
M1 <- initF.FLMatrix(n=5)
V1 <- as.FLVector(sample(1:100,5),connection)
V1R <- as.vector(V1)
P1 <- initF.FLVector(n=5,isRowVec=TRUE)
T1 <- initF.FLTable(rows=5,cols=5)
expect_equal(as.vector(M1$FL),as.vector(M1$R),check.attributes=FALSE)
expect_equal(as.vector(P1$FL),as.vector(P1$R),check.attributes=FALSE)
expect_equal(as.data.frame(M1$FL),as.data.frame(M1$R),check.attributes=FALSE)
testthat::expect_equal(as.matrix(P1$FL),as.matrix(P1$R),check.attributes=FALSE)
testthat::expect_equal(as.matrix(V1),as.matrix(V1R),check.attributes=FALSE)
expect_equal(as.FLMatrix(M1$R,connection),as.matrix(M1$FL),check.attributes=FALSE)
expect_equal(as.FLMatrix(P1$FL),as.matrix(P1$R),check.attributes=FALSE)
expect_equal(as.FLMatrix(V1),as.matrix(V1R),check.attributes=FALSE)
expect_equal(as.FLMatrix(P1$R,connection),as.matrix(P1$R),check.attributes=FALSE)
expect_equal(as.FLVector(M1$R,connection),as.vector(M1$R),check.attributes=FALSE)
expect_equal(as.FLVector(M1$FL),as.matrix(M1$R),check.attributes=FALSE)
})
test_that("check FLCholskeyDecomp",
{
m4 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"MATRIX_ID","ROW_ID","COL_ID","CELL_VAL")
expect_equal(chol(m4),
Matrix::chol(as.matrix(m4)))
})
test_that("check LU Decomposition",
{
m <- initF.FLMatrix(n=5)
expect_equal(AdapteR::expand(AdapteR::lu(m$FL)),
Matrix::expand(Matrix::lu(m$R)),check.attributes=FALSE)
})
devtools::load_all("AdapteR")
test_that("check LU Decomposition",
{
m <- initF.FLMatrix(n=5)
expect_equal(AdapteR::expand(AdapteR::lu(m$FL)),
Matrix::expand(Matrix::lu(m$R)),check.attributes=FALSE)
})
devtools::load_all("AdapteR")
test_that("check LU Decomposition",
{
m <- initF.FLMatrix(n=5)
expect_equal(AdapteR::expand(AdapteR::lu(m$FL)),
Matrix::expand(Matrix::lu(m$R)),check.attributes=FALSE)
})
devtools::load_all("AdapteR")
test_that("check LU Decomposition",
{
m <- initF.FLMatrix(n=5)
expect_equal(AdapteR::expand(AdapteR::lu(m$FL)),
Matrix::expand(Matrix::lu(m$R)),check.attributes=FALSE)
})
test_that("check length",
{
T1 <- initF.FLTable(rows=5,cols=5)
T1R <- as.data.frame(T1)
expect_eval_equal(initF.FLMatrix,AdapteR::length,base::length,n=5)
expect_eval_equal(initF.FLVector,AdapteR::length,base::length,n=5)
expect_eval_equal(initF.FLVector,AdapteR::length,base::length,n=5,isRowVec=TRUE)
expect_equal(AdapteR::length(T1),base::length(T1R),check.attributes=FALSE)
})
## Testing FLTrace
test_that("check FLTrace",
{
expect_eval_equal(initF.FLMatrix,
AdapteR::tr,
psych::tr,
n=5,
isSquare=TRUE)
})
devtools::load_all("AdapteR")
test_that("check the result of the diag of matrix",
{
expect_eval_equal(initF.FLMatrix,
AdapteR::diag,
base::diag,
n=5)
expect_eval_equal(initF.FLVector,
AdapteR::diag,
base::diag,
n=5)
expect_eval_equal(initF.FLVector,
AdapteR::diag,
base::diag,
n=5,isRowVec=TRUE)
expect_eval_equal(initF.FLVector,
AdapteR::diag,
base::diag,
n=1)
expect_eval_equal(initF.FLVector,
AdapteR::diag,
base::diag,
n=1,isRowVec=TRUE)
})
devtools::load_all("AdapteR")
test_that("check FLSV working",
{
M <- initF.FLMatrix(n=5,isSquare=TRUE)$FL
expect_equal(
length(FLSV(M)),
nrow(M)
)
})
test_that("check Hessenberg Decomposition",
{
FLHessen(initF.FLMatrix(n=5,isSquare=TRUE)$FL)
})
test_that("check FLMatrixRREF working",
{
M <- initF.FLMatrix(n=5,isSquare=TRUE)$FL
expect_equal(
dim(FLMatrixRREF(M)),
dim(M)
)
expect_equal(
dimnames(FLMatrixRREF(M)),
dimnames(M)
)
})
## Testing FLMatrixREF
test_that("check FLMatrixREF",
{
FLMatrixREF(initF.FLMatrix(n=5,isSquare=TRUE)$FL)
})
## Testing FLMatrixNorm
test_that("check FLMatrixNorm working",
{
M <- initF.FLMatrix(n=5,isSquare=TRUE)$FL
FLMatrixNorm(M,3)
})
test_that("check Jordan Decomposition",
{
M <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"Matrix_id","ROW_ID","COL_ID","CELL_VAL")
FLJordan(M)
})
rm
dimnames(rm)
dimnames(rm)[[1]][-2]
dimnames(rm)[[1]][-3]
devtools::load_all("AdapteR")
connection <- odbcConnect("Gandalf")
devtools::load_all("AdapteR")
test_that("check FLSolveExcl",
{
M <- initF.FLMatrix(n=5,isSquare=TRUE)$FL
expect_equal(dim(FLSolveExcl(M,3)),dim(M)-1)
expect_equal(dim(FLSolveExcl(M,6)),dim(M))
})
test_that("check FLTriDiag",
{
FLTriDiag(initF.FLMatrix(n=5,isSquare=TRUE)$FL)
})
devtools::load_all("AdapteR")
test_that("check FLEigen",
{
expect_eval_equal(initF.FLMatrix,
AdapteR::eigen,
function(m)
llply(base::eigen(m),
as.numeric),
n=5,
isSquare=TRUE)
})
devtools::load_all("AdapteR")
##Testing FLDiag
test_that("check the result of the diag of matrix",
{
expect_eval_equal(initF.FLMatrix,
AdapteR::diag,
base::diag,
n=5)
expect_eval_equal(initF.FLVector,
AdapteR::diag,
base::diag,
n=5)
expect_eval_equal(initF.FLVector,
AdapteR::diag,
base::diag,
n=5,isRowVec=TRUE)
expect_eval_equal(initF.FLVector,
AdapteR::diag,
base::diag,
n=1)
expect_eval_equal(initF.FLVector,
AdapteR::diag,
base::diag,
n=1,isRowVec=TRUE)
})
#################################################################
########### no equivqlent R functions to test against ###########
################### but functions work ##########################
## Testing FLSV
test_that("check FLSV working",
{
M <- initF.FLMatrix(n=5,isSquare=TRUE)$FL
expect_equal(
length(FLSV(M)),
nrow(M)
)
})
## Testing FLHessenDecomp
test_that("check Hessenberg Decomposition",
{
FLHessen(initF.FLMatrix(n=5,isSquare=TRUE)$FL)
})
## Testing FLMatrixRREF
test_that("check FLMatrixRREF working",
{
M <- initF.FLMatrix(n=5,isSquare=TRUE)$FL
expect_equal(
dim(FLMatrixRREF(M)),
dim(M)
)
expect_equal(
dimnames(FLMatrixRREF(M)),
dimnames(M)
)
})
## Testing FLMatrixREF
test_that("check FLMatrixREF",
{
FLMatrixREF(initF.FLMatrix(n=5,isSquare=TRUE)$FL)
})
## Testing FLMatrixNorm
test_that("check FLMatrixNorm working",
{
M <- initF.FLMatrix(n=5,isSquare=TRUE)$FL
FLMatrixNorm(M,3)
})
##Testing FLJordon
### Phani-- works only with matrices with non-complex
### eigen values. So input taken from DbLytix manual.
test_that("check Jordan Decomposition",
{
M <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"Matrix_id","ROW_ID","COL_ID","CELL_VAL")
FLJordan(M)
})
## Testing FLSolveExcl
test_that("check FLSolveExcl",
{
M <- initF.FLMatrix(n=5,isSquare=TRUE)$FL
expect_equal(dim(FLSolveExcl(M,3)),dim(M)-1)
expect_equal(dim(FLSolveExcl(M,6)),dim(M))
})
## Testing FLTriDiag
test_that("check FLTriDiag",
{
FLTriDiag(initF.FLMatrix(n=5,isSquare=TRUE)$FL)
})
#################################################################################
################### Functions work but output slightly differs ##################
###################### from corresponding R functions ###########################
## gk: discuss with Raman for JIRA DBlytix
## Testing FLEigen
## Phani -- results differ in Teradata and R
test_that("check FLEigen",
{
expect_eval_equal(initF.FLMatrix,
AdapteR::eigen,
function(m)
llply(base::eigen(m),
as.numeric),
n=5,
isSquare=TRUE)
})
## Testing FLSVDecomp
## Phani -- results differ in Teradata and R
test_that("check Singular Value Decomposition",
{
expect_eval_equal(initF.FLMatrix,AdapteR::svd,base::svd,n=5)
})
## Testing FLDet
### Phani-- for some matrices R output = -(DBLytix output)
test_that("check determinant result",{
expect_eval_equal(initF.FLMatrix,AdapteR::det,base::det,n=5,isSquare=TRUE)
})
## Testing FLQRDecomposition
### Phani-- could not calculate pivot properly,
### also, output qr matrix differs from R
test_that("check FLQRDecomposition",
{
M <- initF.FLMatrix(n=5)
expect_eval_equal(initF.FLMatrix,AdapteR::qr,base::qr,n=5)
})
test_that("check FLEigen",
{
expect_eval_equal(initF.FLMatrix,
AdapteR::eigen,
function(m)
llply(base::eigen(m),
as.numeric),
n=5,
isSquare=TRUE)
})
test_that("check Singular Value Decomposition",
{
expect_eval_equal(initF.FLMatrix,AdapteR::svd,base::svd,n=5)
})
test_that("check determinant result",{
expect_eval_equal(initF.FLMatrix,AdapteR::det,base::det,n=5,isSquare=TRUE)
})
m4 <- FLMatrix(connection,"FL_DEMO","tblmatrixMulti",5,"Matrix_id","ROW_ID","COL_ID","CELL_VAL") # Symmetric non-singular matrix of dimension 5x5
det(m4)
View(det)
View(det)
rm(det)
det(m4)
rm(det.FLMatrix)
det(m4)
test_that("check determinant result",{
expect_eval_equal(initF.FLMatrix,AdapteR::det,base::det,n=5,isSquare=TRUE)
})
test_that("check FLQRDecomposition",
{
M <- initF.FLMatrix(n=5)
expect_eval_equal(initF.FLMatrix,AdapteR::qr,base::qr,n=5)
})
devtools::load_all("AdapteR")
})
test_that("check transpose",{
expect_eval_equal(initF.FLMatrix,AdapteR::t,base::t,n=5)
})
## Testing FLRowMeans
test_that("check rowMeans",
{
expect_eval_equal(initF.FLMatrix,
AdapteR::rowMeans,
base::rowMeans,
n=5)
})
## Testing FLRowSums
test_that("check rowSums",
{
expect_eval_equal(initF.FLMatrix,
AdapteR::rowSums,
base::rowSums,
n=5)
})
## Testing FLColMeans
test_that("check colMeans",
{
expect_eval_equal(initF.FLMatrix,AdapteR::colMeans,base::colMeans,n=5)
})
## Testing FLColSums
test_that("check colSums",
{
expect_eval_equal(initF.FLMatrix,AdapteR::colSums,base::colSums,n=5)
})
devtools::load_all("AdapteR")
test_that("check FLQRDecomposition",
{
M <- initF.FLMatrix(n=5)
expect_eval_equal(initF.FLMatrix,AdapteR::qr,base::qr,n=5)
})
