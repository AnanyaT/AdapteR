#'@import methods RODBC
NULL

# /**
#  * Converts List to where clause
#  * @param  {list} x e.g. list(Varx="a",Vary="b")
#  * @return {string}   "Varx='x' AND Vary='y'"
#  */
list_to_where_clause <- function (x) {
	     where_clause <- paste(names(x),x,sep="=\'",collapse="\' AND ");
	     where_clause <- paste(where_clause,"\'",sep="");
	     where_clause <- ifelse(nchar(where_clause) > 1, where_clause, "1=1");
	     where_clause
     }

# /**
#  * Converts List to class Spec. Used for Data Prep
#  * @param  {list} x e.g. list(Varx="a",Vary="b")
#  * @return {string}   "Varx(x), Vary(y)"
#  */
list_to_class_spec <- function (x) {
	classSpec <- paste(names(x),x,sep="(",collapse="), ")
	classSpec <- paste(classSpec,")",sep="")
	classSpec <- ifelse(nchar(classSpec) > 1, classSpec, "");
	classSpec
}

# /**
#  * Converts List to class Spec. Used for Data Prep
#  * @param  {list} x e.g. list(Varx="a",Vary="b")
#  * @return {string}   "Varx(x), Vary(y)"
#  */
list_to_exclude_clause <- function (x) {
	excludeClause <- paste(x, collapse=", ")
	excludeClause
}

#/**
# * Generates Name for a Deep Table
# * @param  {string} TableName Name of Wide Table
# * @return {string}           [description]
# */
gen_deep_table_name <- function(TableName){
	random_no <- rnorm(1);
	paste(TableName,"Deep",round(as.numeric(Sys.time())),round(random_no*random_no*10000000),sep="_");
}

# GenOutTableName: Used in FLMatchIt
gen_out_table_name <- function(TableName){
	random_no <- rnorm(1);
	paste(TableName,"Out",round(as.numeric(Sys.time())),round(random_no*random_no*10000000),sep="_");
}
# */


#/**
# * Generates Name for a Include/Exclude Spec
# * @param  {string} TableName Name of Table
# * @return {string}           [description]
# */
gen_spec_ID <- function(TableName){
	random_no <- rnorm(1);
	paste(TableName,"spec",round(random_no*random_no*10000),sep="_");
}

#/**
# * Assigns CatToDummy  = 1 if categorical variable(s) is(are) present in the FLTable object
# * @param  {string} ClassSpec list
# * @return {int} Value of CatToDummy
# */
calc_cat_to_dummy <- function(ClassSpec) {
	if (length(ClassSpec) == 0) 
    CatToDummy <- 0
	else 
    CatToDummy <- 1;
	CatToDummy
}

#/**
# * Generates query to map variable names to variable IDs
# * @param  {string} AnalysisID Wide to Deep Analysis ID
# * @param  {string} Vars Vector
# * @return {string} Query to get mapping of Variable to VariableID
# */
var_name_to_ID <- function(AnalysisID,Vars){
	
	query <- "SELECT a.COLUMN_NAME,a.Final_VarID as VarID
	FROM fzzlRegrDataPrepMap a 
	WHERE a.AnalysisID = '%s' AND a.COLUMN_NAME IN ('%s')";
	query <- sprintf(query,AnalysisID,paste(Vars,collapse="','",sep=""))
	query <- gsub("[\r\n]", "", query);
	query	
}

#/**
# * Generates Name for an Output Predictions Table
# * @param  {string} TableName Name of Table
# * @return {string}           [description]
# */
gen_out_table <- function(Type,AnalysisID){
	random_no <- rnorm(1);
	paste(Type,"Prediction",AnalysisID,round(random_no*random_no*10000),sep="_");
}

#/**
# * Generates Name for the Output Table for Udt Functions
# * @param {string} MatrixTableName
# * @param {numeric} MatrixID
# * @return {string} 
# */
gen_out_matrix_table <- function(Operation,MatrixTable, Matrix_ID) {
	random_no <- rnorm(1);
	paste(Operation,MatrixTable, Matrix_ID, round(random_no*random_no*10000), sep = "_");
}

#runsql("FLAncovaUdt.sql", CategoryColName, CovariateColName, ValueColName, TableName, WhereClause,)

#/**
# * Run SQL Query generated by binding parameters to template 
# * @param {string} FileName
# * @param {numeric} MatrixID
# * @return {string} 
# */

run_sql <- function (db_connect, sql_file, arg_list)
{
	
	sql_file <- system.file("SQL", sql_file, package="FuzzyR", mustWork = TRUE)
	stopifnot(file.exists(sql_file))
	sql  <- readChar(sql_file, nchar = file.info(sql_file)$size)
	
	names <- names(arg_list)

	# Generate SQL Query by replacing the values in the template
	if(length(arg_list) > 0)
	{
		for(i in 1:length(arg_list) ) 
		{
			sql <- gsub( x = sql, pattern = paste("%",names[i],sep=""), replacement = arg_list[[i]])
		}	
	}
	
	
	sql <- gsub("[\r\n\t]", " ", sql) 
	res <- sqlQuery(db_connect,sql)

	#Check for errors
	if(length(res) == 2)
	{
		if(grepl("ERROR:",res[2], fixed = TRUE))
		{			
			error <- strsplit( res[1], c("]"), fixed = TRUE )[[1]]
			msg <- paste(	"error while executing query: ",sql,
							"\n",error[length(error) - 1],"]: ",error[length(error)],sep="")
			stop(msg)
		}
	}
	res		 	
}

validate_args <- function (arg_list,type_list)
{	
	names <- names(arg_list)
	# Check type for each argument
	for( i in 1:length(arg_list))
	{
		if( typeof(arg_list[[i]]) != type_list[i] )
			stop( paste("Argument Type Mismatch",names[i],"should be of type",type_list[i]) )
	}
}		

is_integer <- function(x) { (x == ceiling(x)||x == floor(x)) }
is_number  <- function(x) { (x == ceiling(x)||x == floor(x))&&(x>=1) }